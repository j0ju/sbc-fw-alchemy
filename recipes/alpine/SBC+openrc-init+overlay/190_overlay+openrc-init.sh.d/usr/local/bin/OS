#!/bin/sh
# (C) 2025 Joerg Jungermann, GPLv2 see LICENSE

set -eu
umask 022

update_root() {
  [ -z "${TRACE:-}" ] || set -x

  if ! [ -L /rom/mnt/CURRENT ]; then
    echo "E: not booted from MMC/SD, cannot update."
    exit 2
  fi

  if [ -z "${1:-}" ]; then
    echo "E: no image file supplied as \$1" 1>&2
    exit 1
  fi
  SQFS="$1"
  MNT="$(mktemp -d)"
  RO=/rom/mnt
  MIN_FREE_kb=5120


  trap cleanup EXIT
  cleanup() {
    local rs=$?
    set +e +x
    umount "$MNT" || \
      echo "E: could not unmount update image from '$MNT'" 1>&2
    rmdir "$MNT" || \
      echo "E: could not remove temp dir '$MNT'" 1>&2
    mount -o remount -r "$RO" || \
      echo "E: could not remount '$RO' read-only" 1>&2
    exit $rs
  }

  if ! mount -o loop "$1" "$MNT"; then
    echo "E: image '$SQFS' could not be mounted, ABORT" 1>&2
    exit 1
  fi

  [ -z "${TRACE:-}" ] || losetup

  NEXT="$(readlink -f /rom/mnt/CURRENT)"

  RUNNING_VERSION="$( cat /rom/boot/build.meta )"
  RUNNING_VERSION="${RUNNING_VERSION##*/}"
  RUNNING="/rom/mnt/ROOTFS.$RUNNING_VERSION"

  RO_FREE_kb="$( df -hk /rom/mnt | awk '$0 ~ "^/" { print $4 }' )"

  NEXT_VERSION=$( cat "$MNT/boot/build.meta" )
  NEXT_VERSION="${NEXT_VERSION##*/}"
  NEXT="$RO/ROOTFS.$NEXT_VERSION"
  NEXT_SIZE_boot_kb=$( sum=0; du -xshkL "$MNT/boot" "$MNT/sbin/busybox.static" | { while read i _; do sum=$(( sum + i)); done; echo $sum ; } )
  NEXT_SIZE_root_kb=$( sum=0; du -xshkL "$SQFS"                                | { while read i _; do sum=$(( sum + i)); done; echo $sum ; } )
  NEXT_SIZE_kb=$(( NEXT_SIZE_root_kb + NEXT_SIZE_boot_kb + MIN_FREE_kb ))

  echo
  echo "I: running image: $RUNNING"
  echo "I: next boot:     $NEXT"
  echo "I: -> new image:  $SQFS"
  echo
  echo "I: running version: $RUNNING_VERSION"
  echo "I: new version    : $NEXT_VERSION"
  echo
  echo "I: free size:   $RO_FREE_kb KB"
  echo
  echo "I: needed size for /: $NEXT_SIZE_root_kb KB"
  echo "I: needed size for /boot: $NEXT_SIZE_boot_kb KB"
  echo "I: needed size: $NEXT_SIZE_kb KB"
  echo

  if [ $NEXT_SIZE_kb -gt $RO_FREE_kb ]; then
    echo "E: too less space on device, ABORT" 1>&2
    exit 1
  fi

  # TODO: check & ensuring structure in /rom/mnt
  #        * /dev /proc /sbin
  #        * /sbin/busybox           (static)
  #        * /sbin/init
  #        * /sbin/preinit -> init   (symlink)
  #        * /boot -> CURRENT/boot   (symlink)

  if ! mount -o remount -w "$RO"; then
    echo "E: could not remount '$RO' read-write, ABORT. See logs!" 1>&2
    exit 1
  fi

  echo "I: creating dir '$NEXT'"
  mkdir -p "$NEXT"
  echo "I: copying /boot to '$NEXT'"
  cp -a "$MNT/boot" "$NEXT"
  echo "I: copying image to '$NEXT/root.sqfs'"
  cp -a "$SQFS" "$NEXT/root.sqfs"

  echo "I: updating next boot"
  rm -f "$RO/CURRENT"
  ln -s "${NEXT##*/}" "$RO/CURRENT"

  RO_UUID="$(findmnt -o UUID -n /rom/mnt)"
  RO_PARTUUID="$(findmnt -o PARTUUID -n /rom/mnt)"

  if [ -f "$NEXT/boot/boot.cmd" ]; then
    echo "I: found /boot/boot.cmd, preparing with PARTUUID=$RO_PARTUUID"
    ( cd "$NEXT/boot"
      sed -i -r -e "/setenv[ ]+rootdev / s/rootdev.*/rootdev PARTUUID=$RO_PARTUUID/" "boot.cmd"
      mkimage -A arm -T script -d "boot.cmd" "boot.scr" > /dev/null
    )
  fi

  if [ -f "$NEXT/boot/armbianEnv.txt" ]; then
    ROOT_CMDLINE="UUID=$RO_UUID"
    echo "I: found /boot/armbianEnv.txt, preparing with UUID=$RO_UUID"
    sed -i -r -e "/rootdev=/ s/=.*$/=$ROOT_CMDLINE/" "$NEXT/boot/armbianEnv.txt"
  fi

  NEXT="$(readlink /rom/mnt/CURRENT)"
  echo "I: --> next boot:     $NEXT"
  echo

  echo "I: space usage in /rom/mnt"
  # TODO: cleanup
  ( cd /rom/mnt
    du -xshkL $(ls -td ROOTFS.*) | \
      ( while read kb f; do
         echo "    $f     $kb KB"
        done
      ) | \
      sed -e "/${NEXT#*/ROOTFS.}/ "'s/$/ <--- next boot/'
  )
  echo
  df -k /rom/mnt
  echo

  # TODO: cleanup old unused ROOTFS? which?
  #       do FS maintenance?
  }

cleanup_root() {
  if ! cd /rom/mnt 2> /dev/null; then
    echo >&2 "E: could not change to OS image partition, ABORT"
    exit 1
  fi
  status_boot
  echo
  echo "CLEANUP"

  act() { echo "I: would delete $*"; }
  nop() { echo "I: keep  $*"; }
  case "${1:-}" in
    --yes | -f | --FORCE | --force )
      RW="mount -o remount -w '$PWD'; trap 'fstrim $PWD || :; mount -o remount -r $PWD' EXIT; RW="
      act() { eval "$RW"; ( set -x; rm -rf "$1" ) }
      #nop() { :; }
      shift
      ;;
  esac

  ls -1d ROOTFS.* 2> /dev/null | \
    sort -nr | \
    while read os; do
      if [ "$CURRENT" = "$os" ]; then
        nop "$os" "   <--- CURRENT"
        continue
      elif [ "$NEXT" = "$os" ]; then
        nop "$os" "   <--- NEXT BOOT"
        continue
      fi

      act "$os"
    done
  }

status_boot() {
  local oPWD="$PWD"
  if ! cd /rom/mnt 2> /dev/null; then
    echo >&2 "E: could not change to OS image partition, ABORT"
    cd "$oPWD"
    return 1
  fi

  NEXT="$(readlink CURRENT)"
  CURRENT="$(findmnt /rom -o SOURCE -n)"
  case "$CURRENT" in
    */loop[0-9] )
      CURRENT="$(losetup -n -O BACK-FILE -l "$CURRENT")"
      CURRENT="${CURRENT%/*}"
      CURRENT="${CURRENT##*/}"
      ;;
    * )
      echo "E: CURRENT is not of known type '$CURRENT' rootfs, abort" >&2
      exit 1
      ;;
  esac

  local FMT='%-8s %-40s\n'
  printf "$FMT" SIZE NAME
  local FMT='%8s %-40s%s\n'
  du -shkx ROOTFS.* | \
    sort -nr | \
    while read size os; do
			[ -d "$os" ] || continue
      e=
      if [ "$CURRENT" = "$os" ]; then
        e=" <--- CURRENT"
      elif [ "$NEXT" = "$os" ]; then
        e=" <--- NEXT BOOT"
      fi
      printf "$FMT" "$size" "$os" "$e"
    done

  echo
  printf "$FMT" "$(df . -hk --output=avail | (read ; read i; echo $i) )" "--- free / size $(df . -hk --output=size | ( read ; read i; echo $i )) ---" ""
  echo

  cd "$oPWD"
}

status_mmc() (
  . /etc/init.d/mmc
  [ -r /etc/conf.d/mmc ] || \
		. /etc/conf.d/mmc
  status
  )

status() (
  status_mmc
	echo
	status_boot
  )

snapshot() {
  echo "E: not implemented, yet."
  exit 69
  }

help() {
cat <<-EOF
	${0##*/} ($0)

	USAGE:
	${0##*/} <COMMAND> [OPTIONS]

	Commands:
	   update <IMAGE>  - update rootfs with SQFS image
	   cleanup         - collect and cleanup old ROOTFS images

	   status          - display status of MMC/eMMC/SD card and boot targets

	   rw              - mount /mmc & overlay read-write ( via /etc/init.d/mmc )
	   ro              - mount /mmc & overlay read-only  ( via /etc/init.d/mmc )

	   snapshot        - NOT implemented, yet - snapshot overlay in /mmc
EOF
}

CMD="${1:-}"
shift 2> /dev/null || :
case "$CMD" in
  update | up )          update_root "$@" ;;
  rw | ro )              /etc/init.d/mmc reload ; /etc/init.d/mmc "$CMD" ; status ;;
  status | stat | st )   status ;;

  # TODO:
  snapshot | snap )      snapshot "$@" ;;
  prune | cleanup )      cleanup_root "$@" ;;

  * | -h | --help | "" ) help ;;
esac

# vim: ts=2 sw=2 et foldmethod=indent ft=sh
