#!/bin/sh
set -eu
umask 022

ASSUME_MSD=n
BOOT=n
DO_BOOT_BACKUP=n
PATCH_DIRS=
NODE=-

usage() {
  echo "usage: $0 <OPTIONS> [PATCH_DIRs|...] [NODE]" >&2
  echo "  --assume-msd     - MSD mode already enabled"
  echo "  --backup-boot    - backup boot"
  echo "  --no-backup-boot - do not backup boot"
  echo "  --boot | -b      - turn node on after write"
  echo "  --boot-mmc | -B  - turn node on after write, RK1: forcing to boot from emmc"
}

while [ ! $# = 0 ]; do
  case "${1:-}" in
    --assume-msd )     ASSUME_MSD=y ; shift ;;
    # for Raspberry PI, keep booting from eMMC, so we can re bootstrap
    --backup-boot )    DO_BOOT_BACKUP=y ; shift ;;
    --no-backup-boot ) DO_BOOT_BACKUP=n ; shift ;;
    --boot | -b )      BOOT=y ; ASSUME_MSD=n ; shift ;;
    --boot-mmc | -B )  BOOT=F ; ASSUME_MSD=n ; shift ;;
    [1234] )
      NODE="$1"
      shift
      ;;
    * )
      if [ -d "${1:-}" ]; then
        PATCH_DIRS="$PATCH_DIRS $1"
        shift
      else
        echo "E: '$1' is not a known option or directory, ABORT" >&2
        echo
        usage
        exit 1
      fi
      ;;
  esac
done

case "$PATCH_DIRS:$NODE" in
  ?*:[1234] ) ;;
  * ) usage ;;
esac

find_usb_device() {
  local PS4="${0##*/}::find_usb_device: "
  for i in $(grep -EH "^Rockchip" /sys/block/*/device/vendor); do
    dev="${i%/device/vendor:*}"
    dev="${dev#/sys/block/}"
    vendor="${i#*:}"
    case "$vendor" in
      Rockchip ) USB_DEVICE=/dev/$dev; SBC_TYPE=rk1; break ;;
      RPi-MSD- ) USB_DEVICE=/dev/$dev; SBC_TYPE=cm4; break ;;
      * ) dev=; break ;;
      # TODO: add support for Raspberry Pi CM5 ?
    esac
  done
}
USB_DEVICE=

CLEANUP_TRAP=:
cleanup() {
  rs=$?
  eval "$CLEANUP_TRAP"
  exit $rs
}
trap 'cleanup' EXIT

MSD_eMMC_cleanup() {
  if [ -d "${MSD_DIR:-}" ]; then
    grep -Eo "${MSD_DIR:-}(|[^ ]+)" /proc/mounts | sort -r | while read line; do
      while umount $line 2> /dev/null; do :; done
    done
    rmdir "$MSD_DIR"
    sync
    echo "I: synced"
  fi
}
# TODO: use mktemp
MSD_DIR=/tmp/${0##*/}.node$NODE.$$
CLEANUP_TRAP="MSD_eMMC_cleanup;${CLEANUP_TRAP%[;:]}"

envsubst() {
  if [ -r "$1" ]; then
    local tmp="$(mktemp -u -p "" HTML_XXXXXXXX)"
    tmp="${tmp#/}"
    local e="cat <<$tmp
$(cat "$1")
$tmp"
    eval "$e"
  else
    return 1
  fi
}

patchNode() {
  mkdir "$MSD_DIR"
  find_usb_device

  echo "I: mount to $MSD_DIR"
  mount "$USB_DEVICE"2 "$MSD_DIR"

  # mount /boot or /boot/firmware
  for boot in /boot/firmware /boot; do
    [ -b "$USB_DEVICE"1 ] || continue
    [ -d "$MSD_DIR/$boot" ] || continue
    if grep "$boot " "$MSD_DIR"/etc/fstab > /dev/null; then
      echo "I: mount $boot to $MSD_DIR$boot"
      mount "$USB_DEVICE"1 "$MSD_DIR/$boot"
      break
    fi
    # fall through
    boot=
  done
  if [ -z "$boot" ]; then
    echo "E: could not if if 1st partitioan is /boot or /boot/firmware, ABORT" >&2
    exit 1
  fi
  BOOT_PART="$USB_DEVICE"1
  BOOT_UUID="$(blkid -o value -s UUID "$BOOT_PART")"
  BOOT_TYPE="$(blkid -o value -s TYPE "$BOOT_PART")"
  ROOTFS_PART="$USB_DEVICE"2
  ROOTFS_UUID="$(blkid -o value -s UUID "$ROOTFS_PART")"
  ROOTFS_TYPE="$(blkid -o value -s TYPE "$ROOTFS_PART")"

  # copy over files, retaining permissions
  # permission changes need to be done via patch.sh
  find "$PATCH_DIR"/ -type f -o -type l | grep -vE "^$PATCH_DIR/.git" | while read src; do
    file="${src#$PATCH_DIR/}"
    dest="$MSD_DIR/$file"
    dest_dir="${dest%/*}"
    mkdir -p "$dest_dir"

    if [ -L "$src" ]; then
      rm -f "$dest"
      cp -a "$src" "$dest"
      echo "I: copied link /${file%.envsubst}"
    else
      case "$src" in
        "$PATCH_DIR/patch.sh" ) continue ;;
        *.envsubst )
          dest="${dest%.envsubst}"
          envsubst "$src" > "$dest"
          echo "I: envsubst /${file%.envsubst}"
          ;;
        * )
          cat "$src" > "$dest"
          echo "I: copied /${file%.envsubst}"
          ;;
      esac
      chown root:root "$dest"
      chmod 0644 "$dest"
    fi
  done

  # exec patch need $TARGET set
  if [ -f "$PATCH_DIR/patch.sh" ]; then
    echo "I: found patch.sh"
    TARGET="$MSD_DIR" \
      /bin/sh "$PATCH_DIR/patch.sh"
    echo "I: patch.sh done"
  fi

  if [ "$DO_BOOT_BACKUP" = y ]; then
    if [ ! -f "$MSD_DIR/$boot"/SNAPSHOT.flash.tar.zst ]; then
      echo "I: dump snapshot of $boot"
      tar cf - -C "$MSD_DIR/$boot" --exclude="SNAPSHOT.*" --exclude="*.bak" --exclude="*~" . | zstd > "$MSD_DIR/$boot/SNAPSHOT.flash.tar.zst" || \
        rm -f "$MSD_DIR/$boot/SNAPSHOT.flash.tar.zst"
    fi
  fi
}

if [ ! "$ASSUME_MSD" = y ]; then
  CLEANUP_TRAP="${CLEANUP_TRAP%[;:]}; off $NODE"
  msd $NODE
fi
if [ "$BOOT" = y ]; then
  CLEANUP_TRAP="${CLEANUP_TRAP%[;:]}; [ ! \$rs = 0 ] || on $NODE"
elif [ "$BOOT" = F ]; then
  CLEANUP_TRAP="${CLEANUP_TRAP%[;:]}; [ ! \$rs = 0 ] || RK1-Boot-from-eMMC $NODE"
fi
for PATCH_DIR in $PATCH_DIRS; do
  patchNode "$PATCH_DIR" "$NODE"
  MSD_eMMC_cleanup
done
